```{r echo=F, message=F, warning=F}
rm(list=ls())
```

# Introduction to `data.table`
This chapter introduces the `data.table` library, a
high-performance alternative to R's standard `data.frame`.
We will cover the basics of working with `data.table`
objects, focusing on key operations such as creating data
tables, subsetting rows, selecting and manipulating columns,
and grouping operations. It explains the `data.table` syntax
`DT[i, j, by]`, where `i` filters rows, `j` selects columns
or performs calculations, and `by` allows for group-wise
operations.

Practical examples demonstrate how to:

- Load the `data.table` library and create a `data.table`.

- Subset rows using integers, logical expressions, and the
  `%in%` operator.

- Select and operate on columns, including summarizing data
  with functions like `mean()` and `sd()`.

- Combine row selection (`i`) and column operations (`j`)
  for more complex data manipulation.

- Group data using the `by` argument to apply functions
  within groups.

- Add and modify columns within a `data.table` using the
  `:=` operator.

- Manage data table copies and understand the difference
  between shallow and deep copies.

- Import data into a `data.table` using the `fread`
  function.

We will also see how to deal with different data formatting,
using `melt` and `dcast` functions for reshaping data tables
from wide format to long or vice versa.

## Loading the `data.table` library and creating a `data.table`
```{r}
# Load the data.table library 
library(data.table)

# Create vectors to later store in a data frame
x <- c('I', 'I', 'I', 'II', 'II', 'II', 'III', 'III', 'III', 'IV', 'IV', 'IV')
y <- c('a', 'a', 'b', 'b', 'c', 'c', 'd', 'd', 'e', 'e', 'f', 'f')
z <- rnorm(12)

# create a data table
dt <- data.table(x, y, z)
dt
```

### Subset rows in `i`

* There are many ways to select rows.

* Set `i` equal to a vector of integers.

* Set `i` equal to a logical expression.

* It will sometimes be useful to use the `%in%` operator
  when specifying `i`.
  
```{r}
# select rows by passing integer indices
dt[1:4]
dt[4:7]
dt[c(2, 4)]
dt[c(2, 5, 11)]

# select rows by passing a logical expression
dt[x=='II']
dt[(x=='II') & (y=='c')]
dt[(x=='II') & (y=='c') & (z > 0)]

# select rows by implementing a logical expression using
# `chaining`
dt[x=='II'][y=='c'][z > 0]

# select rows using the `%in%` operator
dt[x %in% c('I', 'II')]
dt[y %in% c('b', 'f')]

# Notice that using the `%in%` operator is essentially
# performing an *or* logical operation
dt[(x=='I') | (x=='II')]
dt[(y=='b') | (y=='f')]
```

* If you want to operate on every row of some set of
  columns, leave the `i` argument blank.

* This will result in the first character inside the square
  brackets being a comma, which looks a bit strange if
  you're not used to it. Just remember to read it as *select
  every row*.

* `data.table` also provides a keyword `.N` that can be
  useful in a number of ways. One such way is to use it in
  selecting rows as shown in the next code chunk.

```{r}
dt # select every row
dt[,] # select every row
dt[1:.N] # select every row using the .N keyword
dt[2:.N] # select all but the first row using the .N keyword
```

### Select columns with `j`
* To operate on specific columns, set `j` equal to a list of
  the names of the columns you want.

* Inside the square brackets of a `data.table`, `list` can
  be abbreviated with a `.`, which can also look strage at
  first. Once you get used to it, you will appreciate the
  brevity.

### Select and operate on columns with `j`
* You can do a lot more than just return the columns
  specified in `j`. In fact, you can perform any operation
  you want on them.

```{r}
# Select every row of columns y and z the long way
dt[, list(y, z)]

# Select every row of columns y and z the cool way
dt[, .(y, z)]

# select rows 1:4 and return the z column of the result as a
# vector
dt[1:4, z]

# select rows 1:4 and return the z column of the result as a
# data.table
dt[1:4, list(z)]

# select rows 1:4 and return the z column of the result as a
# data.table, but use `.` to abbreviate `list`. This is a
# thing specific to data.table.
dt[1:4, .(z)]

# select and operate on columns
# select rows 1:4 and return a summary statistic of the
# resulting z column
dt[1:4, mean(z)]
dt[1:4, sd(z)]

# notice the default naming of the columns in the following
# result
dt[1:4, list(mean(z), sd(z))]

# control the names of the resulting columns
dt[1:4, list(z_mean = mean(z), z_sd = sd(z))]

# select all rows and compute summary statistics of the
# resulting data.table
dt[, .(mean(z), sd(z))] # default column names
dt[, list(z_mean=mean(z), z_sd=sd(z))] # custom column names
```


### Combine `i` and `j`

* It is straightforward to combine `i` and `j`.

```{r}
# Select all rows for which x==II and return columns y and z
dt[x=='II', .(y, z)]
```


### Group using `by`

* The real magic of `data.table` comes in the power of the
  `by` argument.

* `by` allows you apply the operation that you specify with
  `j` to separate groups of rows defined by the unique
  values in the columns specified in `by`.

* Put another way, whatever column you pass to `by` will be
  split up into groups with each unique value getting its
  own group. Those groups will then be applied to the
  columns you specify in `j` and the operation also
  specified in `j` will be applied only to rows from the
  same group. Then, after all is done, everything is put
  back into a single `data.table`.

```{r}
# inefficient way to group by x
dt[x=="I", mean(z)]
dt[x=="II", mean(z)]
dt[x=="III", mean(z)]
dt[x=="IV", mean(z)]

# efficient and beautiful way to group by x
dt[, mean(z), .(x)]

# the efficient and beautiful way of doing things extends to
# grouping by multiple variables with ease
dt[, mean(z), .(x, y)]

# return more than one summary statistic grouped by x
dt[, .(mean(z), sd(z)), .(x)] # default naming of resulting columns
dt[, .(z_mean=mean(z), z_sd=sd(z)), .(x)] # custom naming of resulting columns
```

### Adding and modifying columns

* Use the `:=` operator inside the `j` argument of a
  `data.table` to add or modify a column.

```{r, error=T}
# if you pass a single number, data.table will fill the
# entire column with that value
dt[, a := 9]

# otherwise, just pass a vector of the same length as the
# data.table
dt[, b := seq(2, 24, 2)]

# notice that you get an error if you try to create a column
# using a vector that isn't exactly the correct length
dt[, b := seq(2, 26, 2)]
# redefine or modify an existing column the same way
dt[, b := seq(4, 48, 4)]

# remove a column using := and the NULL keyword
dt[, b := NULL]

# don't use the `<-` operator and the `:=`operator at the
# same time. It works but is inefficient
dt <- dt[, c := 9] # don't do this

# it all works the same with non-numerical columns
dt[, betsy := 'mouse']
dt[, betsy := c('mouse', 'rat')] # notice the error
new_col_betsy <- rep(c('mouse', 'rat'), 6)
dt[, betsy := new_col_betsy] # add betsy
```

### Be careful when copying `data.table` objects

* `dt2 = dt` creates a *shallow copy*. This means that there
  is really only one `data.table` object in memory, but it
  can be referred to by both names.

* This means that changes to `dt2` will be reflected in `dt`
  and vice-versa.

* You can show that this is the case by modifying dt2 and
  observing that dt also changes (see code chunks below).

* To create a *deep copy* use `dt2 = data.table(dt)`.

```{r}
# print dt to see what it looks like before messing with it
dt 

# this is a shallow copy
dt_copy = dt
dt_copy[, a := NULL]

# notice we also deleted the `a` column from dt, not just from
# dt_copy
dt

# this is a deep copy
dt_copy = data.table(dt)
dt_copy[, x := NULL]

# now our changes to dt_copy didn't also change dt
dt
```

### Getting data into a `data.table`
* The first and primary method that will use to get data
  into a `data.table` is the `fread` function, which is part
  of the `data.table` library.

* The following code chunk reads a .csv file into
  `data.table`.

```{r}
# Location of the csv file
# can be on the internet or on your local machine
f <- 'https://crossley.github.io/cogs2020/data/maze/maze.csv'

# use the fread function
d <-fread(f)
d
```


* A second method that we will sometimes use to get data into
  a `data.table` is as follows:

```{r}
s1 <- "family_id age_mother dob_child1 dob_child2 dob_child3
               1         30 1998-11-26 2000-01-29         NA
               2         27 1996-06-22         NA         NA
               3         26 2002-07-11 2004-04-05 2007-09-02
               4         32 2004-10-10 2009-08-27 2012-07-21
               5         29 2000-12-05 2005-02-28         NA"

DT <- fread(s1)
DT
```

* This can be useful in a few odd circumstances. For
  example, you may wish to copy some text in another program
  and paste it over into your `R` session to turn it into a
  `data.table`.
  
### Wide vs long format
* The following `data.table` is in **long** format:

```{r, echo=F}
d <- fread('https://crossley.github.io/cogs2020/data/maze/d_long.csv')
d
```

* The following `data.table` is in **wide** format:

```{r, echo=F}
d <- fread('https://crossley.github.io/cogs2020/data/maze/d_wide.csv')
d
```

* Each format has its pros and cons, and you may find yourself
  needing to switch between them even within the same dataset.
  
* To go from wide to long format you should use the `melt`
  function from the `data.table` library.
  
* To go from long to wide format you should use the `dcast`
  function from the `data.table` library.
  
* Using these functions is just a bit beyond the scope of this
  lecture, but we will return later in the unit to learn about
  them. If you are feeling confident in your use of
  `data.table` then you may enjoy getting a little ahead of
  the game by reading the following vignette:

  [reshaping `data.table`
  vignette](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html)
