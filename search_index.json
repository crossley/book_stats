[["index.html", "Data analysis and statistics for cognitive neuroscience 1 Introduction to the book", " Data analysis and statistics for cognitive neuroscience Matthew J. Crossley 2024-02-11 1 Introduction to the book First and foremost, this book is an active work in progress and is liable to change somehwat from week to week. If you find errors, or if you find any section particularly confusion, please feel free to reach out to me for help. Statistics is often taught to the aspiring cognitive neuroscientist as a series of cookbook recipes, without imparting any deep understanding of the reasoning that generated those recipes in the first place. Too often I have seen the deer in headlights look on the newly minted graduate student when a dataset they are asked to analyse does not fit the mold of the recipes they have been previously exposed to. The ambition of this book is to topple this situation on its head. We will repeatedly emphasize developing the reasoning skills necessary to understand the recipes, and to write our own recipes when called for. In the course of this book we will nevertheless encounter the usual suspects – t-tests, ANOVAs, regressions, and so – but you may find that we go deeper into fewer recipes rather than skimming the surface of many. We will use the R programming language throughout this book. We use R because it is mature; It is widely embraced in psychology and neuroscience; It is widely embraced in data science; It is relatively easy to learn. That said, it is not the only good option. Python, for example, is excellent. Matlab is also excellent – though not as widely used and not as free – but it is still widely used in academia. You might even run into more obscure languages here and there. At the end of the day, we have to pick one. R is a good place to start and it will offer you excellent return on investment. Just as R is a reasonable choice for a programming language, Rstudio is a reasonable choice for an integrated development environment (IDE). It is free, it is widely used, and it is well supported. That said, there are numerous options for programming in R. I have old-school computer science friends that edit code in a plain text file and execute it straight from a terminal. There is absolutely nothing wrong with this. Program where you like. But why bother learning to code now that chatGPT is so good at writing code for us? That is a very good question. The point I would like you to notice is how this question underscores the importance of developing our reasoning capacity both as statisticians and as programmers. The nuts and bolts of getting code to run or have some kind of statistical test or another performed on your data is only going to become easier and easier and more and more automated with increasing AI capabilities. But the reasoning behind the nuts and bolts will endure the test of time. "],["introduction-to-r.html", "2 Introduction to R 2.1 Basics 2.2 Functions 2.3 Data types 2.4 Containers 2.5 Loops 2.6 Conditional flow 2.7 Custom functions 2.8 Inspect existing objects 2.9 Summary", " 2 Introduction to R This chapter provides an introduction to R, covering basic concepts like defining variables, performing mathematical operations, and using built-in functions. It also introduces various data types (numeric, character, logical, and factor) and containers (vector, list, and data frame) in R, along with how to create and access their elements. It also covers control flow with for and while loops, conditional flow with if statements, and the creation of custom functions. Lastly, it discusses inspecting objects using functions like ls(), rm(), class(), str(), head(), tail(), and summary() to understand and manage the R environment. 2.1 Basics # Use R as a calculator 2 + 2 ## [1] 4 # Store results in variables x &lt;- 2 + 2 x ## [1] 4 # Perform mathematical operations on variables x &lt;- 2 + 2 y &lt;- 3 + 7 x + y ## [1] 14 2.2 Functions Functions are objects that take arguments as inputs, perform some operation on those inputs, and return the results. ls() is a function that reports what objects (e.g., variables you have defined) are in the current environment and therefore available for you to interact with. ls() ## [1] &quot;x&quot; &quot;y&quot; rm() is a function that can remove objects from the current environment. It takes several arguments. Type ?rm() to see help information on how to use it. We will commonly combine ls() and rm() to remove all objects from the current environment. This is a good thing to do at the beginning of every new script you write. # Remove all objects from the current R session. rm(list = ls()) 2.3 Data types 2.3.1 numeric x &lt;- 2 class(x) ## [1] &quot;numeric&quot; 2.3.2 character x &lt;- &#39;a&#39; class(x) ## [1] &quot;character&quot; 2.3.3 logical x &lt;- TRUE class(x) ## [1] &quot;logical&quot; 2.3.4 factor A factor is a categorical data type. They are most often used to code for different conditions in an experiment. x &lt;- factor(1) class(x) ## [1] &quot;factor&quot; 2.4 Containers 2.4.1 vector Create a vector with the function c(). The elements of a vector must be of the same type. Access element i of vector x with square brackets (e.g., x[i]) # Create a vector with any three numbers you like. x &lt;- c(1, 2, 3.14159) x ## [1] 1.00000 2.00000 3.14159 # Access the third element of x x3 &lt;- x[3] x3 ## [1] 3.14159 2.4.2 list Create a list with the function list() The elements of a list can be of different types. Access element i of list x with double square brackets (e.g., x[[i]]) # Create a three element list containing one numeric # item, one `character` item, and one logical item. x &lt;- list(3.14159, &#39;pi&#39;, TRUE) x ## [[1]] ## [1] 3.14159 ## ## [[2]] ## [1] &quot;pi&quot; ## ## [[3]] ## [1] TRUE # Access the third element of x x3 &lt;- x[[3]] x3 ## [1] TRUE 2.4.3 data.frame Create a data.frame with the function data.frame() -data.frame is pretty close what you might think of as an excel spreadsheet. Access column x in data.frame df with the $ operator (e.g., df$x). # Create vectors to later store in a data frame x &lt;- c(&#39;I&#39;, &#39;I&#39;, &#39;I&#39;, &#39;II&#39;, &#39;II&#39;, &#39;II&#39;, &#39;III&#39;, &#39;III&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;IV&#39;, &#39;IV&#39;) y &lt;- c(&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;e&#39;, &#39;e&#39;, &#39;f&#39;, &#39;f&#39;) z &lt;- rnorm(12) # Create the data frame df &lt;- data.frame(x, y, z) df ## x y z ## 1 I a -1.6523276 ## 2 I a 0.2504072 ## 3 I b 2.0398057 ## 4 II b -0.3457887 ## 5 II c -0.8629809 ## 6 II c 1.2331722 ## 7 III d -0.1642727 ## 8 III d 1.1463085 ## 9 III e -1.0988434 ## 10 IV e -0.1129436 ## 11 IV f -0.9044868 ## 12 IV f -0.9991266 # Access column x df$x ## [1] &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;II&quot; &quot;II&quot; &quot;II&quot; &quot;III&quot; &quot;III&quot; &quot;III&quot; &quot;IV&quot; &quot;IV&quot; &quot;IV&quot; 2.5 Loops 2.5.1 for loops for loops will run a chunk of code repeatedly for a fixed number of iterations. The general syntax of a for loop is as follows: for(x in y) { # On the first iteration, `x` will take the value `y[1]` # On the second iteration, `x` will take the value `y[2]` # On the third iteration, `x` will take the value `y[3]` # The loop will end after `x` has taken the value `y[length(y)]` # That is, the loop will end when we have iterated through # all elements in `y` } As an example suppose we want to print the numbers 1, 2, 3 # dumb monkey way to print 1, 2, 3 print(1) ## [1] 1 print(2) ## [1] 2 print(3) ## [1] 3 # smart monkey way to print 1, 2, 3 for(i in c(1, 2, 3)) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 2.5.2 while loops while loops will run a chunk of code repeatedly over and over again until some logical condition is met. You have to be careful with these, because if your code never sets up a stopping condition, then the loop will execute until your computer turns to dust. The general syntax of a for loop is as follows: condition &lt;- TRUE while(condition) { # On the first iteration, `x` will take the value `y[1]` # On the second iteration, `x` will take the value `y[2]` # On the third iteration, `x` will take the value `y[3]` # The loop will end only when `condition` is set to `FALSE` } Lets again consider the example printing the numbers 1, 2, 3 # dumb monkey way to print 1, 2, 3 print(1) ## [1] 1 print(2) ## [1] 2 print(3) ## [1] 3 # smart monkey way to print 1, 2, 3 x &lt;- 1 while(x &lt; 4) { print(x) x &lt;- x + 1 # without this line the loop would run forever } ## [1] 1 ## [1] 2 ## [1] 3 2.6 Conditional flow Very often we will want to execute a chunk of code only in some situations (e.g., for a particular experiment condition) and we will want to run some other chunk of code in other situations. The primary method for doing this is to use if statements. The general syntax of an if statement is as follows: if(condition) { # code to run if condition is TRUE } else { # code to run if condition is FALSE } For example, suppose we want to print whether or not a number is less than 5. x &lt;- 3 if(x &lt; 5) { print(&#39;x is less than 5&#39;) } else { print(&#39;x is greater than or equal to 5&#39;) } ## [1] &quot;x is less than 5&quot; 2.7 Custom functions Custom functions are very useful because they allow us to flexibly reuse the same chunk of code in different places without having to rewrite the entire chunk. The general syntax for defining functions is as follows: function_name &lt;- function(argument_1, argument_2, ...) { ## code to run when the function is called. Can use ## `argument_1`, `argument_2`, and any other argument ## passed in. ##... return(the_result) } function_name is the name of the function. argument_1, argument_2, etc. are variables that you want the code chunk inside the function to use. the_result is a variable that you will have to be careful to define in the code chunk in the function. Consider the following example: my_func &lt;- function(x, y) { z &lt;- x + y - 1 return(z) } my_func(x=2, y=3) ## [1] 4 my_func take two arguments x and y and returns x + y - 1 2.8 Inspect existing objects R has many built-in functions that are useful for inspecting what sort of thing an existing object is. We illustrate the use of some of these functions below. # define some variables (objects) to inspect var_1 &lt;- 10 var_2 &lt;- &quot;apple&quot; var_3 &lt;- TRUE var_4 &lt;- c(1, 2, 3) var_5 &lt;- list(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) var_6 &lt;- data.frame(v4=var_4, v5=var_5) # substitute different variables into the following # functions to see how they help you inspect existing # objects. str(var_1) ## num 10 class(var_1) ## [1] &quot;numeric&quot; head(var_1) ## [1] 10 tail(var_1) ## [1] 10 summary(var_1) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 10 10 10 10 10 10 2.9 Summary Here’s a list of the R functions we saw in the above examples: ls() - Lists objects in the current environment. rm() - Removes objects from the current environment. class() - Returns the class (type) of an object. factor() - Creates a factor (categorical data type). c() - Combines values into a vector or list. list() - Creates a list. data.frame() - Creates a data frame. rnorm() - Generates normally distributed random numbers. print() - Prints its argument. str() - Displays the structure of an R object. head() - Returns the first parts of an object. tail() - Returns the last parts of an object. summary() - Provides a summary of an object’s properties. Additionally, we saw how to create and use custom functions, as well as how to use control flow constructs like for loops, while loops, and if statements. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
